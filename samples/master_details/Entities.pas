unit Entities;

interface

uses
  MVCFramework.Serializer.Commons,
  MVCFramework.ActiveRecord,
  MVCFramework.Nullables,
  System.Classes,
  MVCFramework, System.Generics.Collections,
  MVCFramework.SQLGenerators.Firebird;

type
  TPhone = class;

  [MVCNameCase(ncLowerCase)]
  [MVCTable('people')]
  [MVCEntityActions([eaCreate, eaRetrieve, eaUpdate, eaDelete])]
  TPerson = class(TMVCActiveRecord)
  private
    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]
    fID: NullableInt64;
    [MVCTableField('LAST_NAME')]
    fLastName: string;
    [MVCTableField('FIRST_NAME')]
    fFirstName: string;
    [MVCTableField('DOB')]
    fDOB: TDate;
    [MVCTableField('FULL_NAME')]
    fFullName: string;
    [MVCTableField('IS_MALE')]
    fIsMale: Boolean;
    [MVCTableField('NOTE')]
    fNote: string;
    [MVCTableField('PHOTO')]
    fPhoto: TStream;
    fPhones: TObjectList<TPhone>;

    procedure SetLastName(const Value: string);
    procedure SetID(const Value: NullableInt64);
    procedure SetFirstName(const Value: string);
    procedure SetDOB(const Value: TDate);
    function GetFullName: string;
    procedure SetIsMale(const Value: Boolean);
    procedure SetNote(const Value: string);
  protected
    procedure OnAfterLoad; override;
    procedure OnAfterInsertOrUpdate; override;
    procedure OnAfterDelete; override;
    procedure OnValidation(const Action: TMVCEntityAction); override;
    procedure OnBeforeInsert; override;
    procedure MergePhones(NewPhones: TObjectList<TPhone>);
  public
    constructor Create; override;
    destructor Destroy; override;
    procedure Merge(const Person: TPerson);
    property ID: NullableInt64 read fID write SetID;
    property LastName: string read fLastName write SetLastName;
    property FirstName: string read fFirstName write SetFirstName;
    property DOB: TDate read fDOB write SetDOB;
    property FullName: string read GetFullName;
    property IsMale: Boolean read fIsMale write SetIsMale;
    property Note: string read fNote write SetNote;
    property Photo: TStream read fPhoto;
    property Phones: TObjectList<TPhone> read fPhones;
  end;

  [MVCNameCase(ncLowerCase)]
  [MVCTable('phones')]
  [MVCEntityActions([eaCreate, eaRetrieve, eaUpdate, eaDelete])]
  TPhone = class(TMVCActiveRecord)
  private
    [MVCTableField('id', [foPrimaryKey, foAutoGenerated])]
    fID: NullableInt64;
    [MVCTableField('phone_number')]
    fPhoneNumber: string;
    [MVCTableField('number_type')]
    fNumberType: string;
    [MVCTableField('id_person')]
    fIDPerson: Integer;
  protected
    procedure OnValidation(const Action: TMVCEntityAction); override;
  public
    property ID: NullableInt64 read fID write fID;
    property IDPerson: Integer read fIDPerson write fIDPerson;
    property PhoneNumber: string read fPhoneNumber write fPhoneNumber;
    property NumberType: string read fNumberType write fNumberType;
  end;

  [MVCNameCase(ncLowerCase)]
  [MVCTable('PEOPLE')]
  [MVCEntityActions([eaCreate, eaRetrieve, eaUpdate, eaDelete])]
  TContact = class(TPerson)
  private
    function GetPhones: TObjectList<TPhone>;
  public
    property Phones: TObjectList<TPhone> read GetPhones;
  end;

implementation

uses
  System.DateUtils,
  System.SysUtils, MVCFramework.Logger, System.Generics.Defaults;

{ TPersona }

constructor TPerson.Create;
begin
  inherited;
  fPhoto := TMemoryStream.Create;
  fPhones := TObjectList<TPhone>.Create(true);
end;

destructor TPerson.Destroy;
begin
  fPhoto.Free;
  fPhones.Free;
  inherited;
end;

function TPerson.GetFullName: string;
begin
  Result := fFullName;
end;

procedure TPerson.Merge(const Person: TPerson);
begin
  self.LastName := Person.LastName;
  self.FirstName := Person.FirstName;
  self.DOB := Person.DOB;
  self.IsMale := Person.IsMale;
  self.Note := Person.Note;
  self.Photo.Size := 0;
  self.Photo.CopyFrom(Person.Photo, 0);
  MergePhones(Person.Phones);
end;

procedure TPerson.MergePhones(NewPhones: TObjectList<TPhone>);
var
  lPhone: TPhone;
  lNewPhonesIDs: TArray<Int64>;
  I: Integer;
  lIndex: Integer;
begin
  I := 0;
  while I < NewPhones.Count do
  begin
    if not NewPhones[I].ID.HasValue then
    begin
      fPhones.Add(NewPhones.Extract(NewPhones[I]));
      fPhones.Last.IDPerson := self.ID;
    end
    else
    begin
      System.Insert(NewPhones[I].ID.Value, lNewPhonesIDs, 0);
      Inc(I);
    end;
  end;
  TArray.Sort<Int64>(lNewPhonesIDs);

  // delete
  for lPhone in Phones do
  begin
    if lPhone.ID.HasValue then
    begin
      if not TArray.BinarySearch<Int64>(lNewPhonesIDs, lPhone.ID.Value, lIndex) then
      begin
        lPhone.Delete;
        self.Phones.Remove(lPhone);
      end;
    end;
  end;

  // move all the upd elements into dest list
  while NewPhones.Count > 0 do
  begin
    Phones.Add(NewPhones.ExtractAt(0));
  end;
end;

// procedure TPerson.MergePhones(NewPhones: TObjectList<TPhone>);
// var
// lPhone: TPhone;
// lNewPhones: TArray<TPhone>;
// I: Integer;
// lIndex: Integer;
// lPhonesComparer: IComparer<TPhone>;
// begin
// I := 0;
// lPhonesComparer := TComparer<TPhone>.Construct(
// function(const a, b: TPhone): Integer
// begin
// if not(a.ID.HasValue or b.ID.HasValue) then
// raise Exception.Create('Cannot compare Nulls');
// if a.ID.Value > b.ID.Value then
// Exit(1);
// if a.ID.Value < b.ID.Value then
// Exit(-1);
// Result := 0;
// end);
//
// while I < NewPhones.Count do
// begin
// if not NewPhones[I].ID.HasValue then
// begin
// fPhones.Add(NewPhones.Extract(NewPhones[I]));
// fPhones.Last.IDPerson := Self.ID;
// end
// else
// begin
// Inc(I);
// end;
// end;
//
// lNewPhones := NewPhones.ToArray();
// TArray.Sort<TPhone>(lNewPhones, lPhonesComparer);
//
// // delete
//
/// /  for lPhone in Phones do
// I := 0;
// while I < Phones.Count do
// begin
// lPhone := Phones[I];
// if lPhone.ID.HasValue then
// begin
// if not TArray.BinarySearch<TPhone>(lNewPhones, lPhone, lIndex, lPhonesComparer) then
// begin
// lPhone.Delete;
// Self.Phones.Remove(lPhone);
// Continue;
// end
// else
// begin
// Phones.Delete(I);
// end;
// end;
// Inc(i);
// end;
//
// // move all the upd elements into dest list
// // while NewPhones.Count > 0 do
// // begin
// // Phones.Add(NewPhones.ExtractAt(0));
// // end;
// end;

procedure TPerson.OnAfterDelete;
var
  lPhone: TPhone;
begin
  inherited;
  for lPhone in fPhones do
  begin
    lPhone.Delete;
  end;
end;

procedure TPerson.OnAfterInsertOrUpdate;
var
  lPhone: TPhone;
begin
  inherited;
  for lPhone in fPhones do
  begin
    lPhone.IDPerson := self.ID.Value;
    lPhone.Store;
  end;
end;

procedure TPerson.OnAfterLoad;
var
  lPhones: TObjectList<TPhone>;
begin
  inherited;
  lPhones := TMVCActiveRecord.SelectRQL<TPhone>('eq(idperson,' + self.ID.Value.ToString +
    ')', 1000);
  try
    lPhones.OwnsObjects := False;
    fPhones.Clear;
    fPhones.AddRange(lPhones);
  finally
    lPhones.Free;
  end;
end;

procedure TPerson.OnBeforeInsert;
begin
  inherited;
  // TMemoryStream(fPhoto).LoadFromFile('C:\DEV\dmvcframework\samples\_\customer_small.png');
end;

procedure TPerson.OnValidation(const Action: TMVCEntityAction);
begin
  inherited;
  if fLastName.Trim.IsEmpty or fFirstName.Trim.IsEmpty then
    raise EMVCActiveRecord.Create('Validation error. FirstName and LastName are required');
end;

procedure TPerson.SetLastName(const Value: string);
begin
  fLastName := Value;
end;

procedure TPerson.SetNote(const Value: string);
begin
  fNote := Value;
end;

procedure TPerson.SetDOB(const Value: TDate);
begin
  fDOB := Value;
end;

procedure TPerson.SetID(const Value: NullableInt64);
begin
  fID := Value;
end;

procedure TPerson.SetIsMale(const Value: Boolean);
begin
  fIsMale := Value;
end;

procedure TPerson.SetFirstName(const Value: string);
begin
  fFirstName := Value;
end;

{ TPhone }

procedure TPhone.OnValidation(const Action: TMVCEntityAction);
begin
  inherited;
  if fPhoneNumber.Trim.IsEmpty then
    raise EMVCActiveRecord.Create('Phone Number cannot be empty');
end;

{ TContact }

function TContact.GetPhones: TObjectList<TPhone>;
begin
  Result := TMVCActiveRecord.SelectRQL<TPhone>('eq(IDPerson, ' + self.ID.Value.ToString + ')', 100);
end;

initialization

finalization

end.
